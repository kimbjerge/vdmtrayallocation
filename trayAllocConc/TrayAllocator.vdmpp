-- ===============================================================================================================
-- TrayAllocator in tray allocation for a sortation system
-- By José Antonio Esparza and Kim Bjerge - spring 2010
-- ===============================================================================================================

class TrayAllocator

	types
		public ThroughputResult::
						traysWithItemOnSorter : nat
						twoTrayItemsOnSorter : nat 
						traySteps : nat
						inductedItems : nat
						calcThroughput : real;
		

	values
		public InductionSeperation: nat = 2;
		public NumOfInductions : nat = 3;
		public NumOfTrays : nat = 20;
		public SecInHour : nat = 3600 	-- Number of seconds in an hour

	instance variables
		-- Ensure sufficient number of trays on sorter ring based on inductions and separation
		inv NumOfTrays > InductionSeperation * NumOfInductions; 

		countTraySteps : nat := 0;  	-- Used for calculation of throughput
		countItemsInducted : nat := 0;  -- Counts the number of items inducted 
		
		-- Induction group and invariants 
		public inductionGroup : seq of InductionController := [];
		inv len inductionGroup = NumOfInductions; 
		-- Induction id and inds of inductionGroup sequence must be the same
		inv forall id in set inds inductionGroup & inductionGroup(id).GetId() = id;
			
		-- Sorter ring and invariants	
		public sorterRing : inmap Tray`UID to Tray;
		inv card dom sorterRing = NumOfTrays;
		-- Tray id and dom of sorterRing map must be the same
		inv forall id in set dom sorterRing & sorterRing(id).GetId() = id;
		
		-- Tray at card reader and invariants
		public trayAtCardReader : [Tray`UID] := nil;
		-- trayAtCardReader must be a valid tray in sorterRing
		inv trayAtCardReader <> nil  => trayAtCardReader in set dom sorterRing;
		
		-- Allocation "strategy pattern" for one and two tray items
		oneTrayStrategy : AllocatorOneTray;
		twoTrayStrategy : AllocatorTwoTray;	
		
		-- Map of waiting inductions with an item to be inducted 
		itemsToInductMap : map nat to (InductionController * Item) := {|->};
		-- waitingThreads : seq of nat := [];
		-- inv elems waitingThreads = dom itemsToInductMap;
						
	operations
	
    -- TrayAllocator constructor
	public TrayAllocator: seq of InductionController ==> TrayAllocator
	TrayAllocator(ig) ==
	(
	    sorterRing := {num |-> new Tray(num) | num in set {1,...,NumOfTrays}};
	    inductionGroup := ig;
        
        -- Creating strategies for allocation of one and two tray items
        oneTrayStrategy := new AllocatorOneTray(self);
        twoTrayStrategy := new AllocatorTwoTray(self);
	);

    -- Simulate sorter-ring moved one tray step
	public CardReader: Tray`UID * Tray`State  ==> ()
	CardReader(uid, state) ==
	(
	   	-- Update current tray at card reader
	    trayAtCardReader := uid;
	    
	    -- Simulate change of Tray state !!!
	    -- sorterRing(trayAtCardReader).SetState(state);
	 	
	 	-- Count the number of tray steps 
		countTraySteps := countTraySteps + 1;
	)
	pre uid in set dom sorterRing;
	
	-- Inducting item on sorter if empty trays and no higher induction priority
	public InductItem: InductionController * Item ==> bool
	InductItem(ic, item) ==
	(
		dcl strategy : AllocatorStrategy;
		
		-- Determine the strategy to compute the allocation of trays
		let numTrays = item.GetSizeOfTrays()
		in 
			cases numTrays:
				1 -> strategy := oneTrayStrategy,
				2 -> strategy := twoTrayStrategy
			end;
		
		-- Central part of the Tray allocation algorithm 
		-- Look for inductions with higher priority before allocation of empty trays
		if strategy.InductionsWithHigherPriority(ic)
		then
		 	return false
		else
			let trays = strategy.AllocateTray(ic.GetId())
			in 
			    if trays = {}
			    then 
			    	return false
			    else
			    ( 
			    	countItemsInducted := countItemsInducted + 1;
					IO`print("*Induction id " ^ String`NatToStr(ic.GetId()) ^ "\n");
					-- Assign item to trays
			    	PutItemOnTrays(item, trays);
			    	return true;
			    ) 
	)
	pre ic in set elems inductionGroup and item.GetSizeOfTrays() <= 2;  -- To be changed if Tray`ItemMaxTrays is increased
	
	-- Assign item on empty trays 
	private PutItemOnTrays: Item * set of Tray ==> ()
	PutItemOnTrays(item, trays) ==
		if trays <> {} then
		let t in set trays
		in 
		( 
			t.ItemOnTray(item);
			PutItemOnTrays(item, trays \ {t});
		)
	pre forall t in set trays & t.IsTrayEmpty();
	
	-- Returns true if sorter is full
	public IsSorterFull: () ==> bool
	IsSorterFull() ==
	 	return forall id in set dom sorterRing & sorterRing(id).GetState() = <Full>;

	-- Returns calculated throughput of soter capacity for current state of sorter ring
	public GetThroughput: () ==> ThroughputResult
	GetThroughput () ==
		CalculateThroughput(countTraySteps, rng sorterRing, countItemsInducted);
	 
	-- Called by InductionController thread requesting to induct item
	public RequestTray: nat * InductionController * Item ==> ()
	RequestTray (t, ic, item) ==
			AddItem(t, ic, item)
	pre t not in set dom itemsToInductMap;
		
    -- Thread blocked until removed from Map waitingICs
	public Wait: () ==> ()
	Wait() == skip;

    -- Add induction waiting with item to induct
	AddItem: nat * InductionController * Item ==> ()
	AddItem (t, ic, item) ==
	atomic
	(
			itemsToInductMap := itemsToInductMap munion {t |-> mk_(ic, item)};
			-- waitingThreads := waitingThreads ^ [t];
	)
	pre t not in set dom itemsToInductMap;
	
    -- Remove induction waiting with item to induct
	RemoveItem: nat ==> ()
	RemoveItem (t) ==
	atomic 
	(
			itemsToInductMap := {t} <-: itemsToInductMap;
			-- waitingThreads := tl waitingThreads;
	)
	pre t in set dom itemsToInductMap;
	
	-- Returns 
	CheckItemsToInduct: () ==> ()
	CheckItemsToInduct () ==
	(
		-- Induct items for all waiting inductions
		/* Version random service */
		for all t in set dom itemsToInductMap
		do
			let mk_(ic, item) = itemsToInductMap(t)
			in
				if InductItem(ic, item) then
				(
					ic.InductFirstItem();
					RemoveItem(t);
				)
				else 
					ic.IncrementPriority();
					
		-- Induct items for all waiting inductions
		/*
		if waitingThreads <> [] then
		for i = 1 to len waitingThreads
		do
			let t = waitingThreads(i),
				mk_(ic, item) = itemsToInductMap(t)
			in
				if InductItem(ic, item) then
				(
					ic.InductFirstItem();
					RemoveItem(t);
				)
				else 
					ic.IncrementPriority();
		*/
		
	);
			

	functions

	-- Calculates the current throughput based on items on sorter ring 
	/*
	Calculation as sum of simulation time steps = number of steps * Tray`TraySize/SorterEnviroment`Speed
    throughput calculated as items inducted in simulation time converted to items/hour 
    calculate the number of items inducted = number of tray with status equal <full> minus sum of two tray items divied by 2
	*/
	private CalculateThroughput: nat * set of Tray * nat-> ThroughputResult
	CalculateThroughput(steps, trays, items) ==
		let runTime :real = steps * (Tray`Size/SorterEnviroment`Speed),
			traysWithItems = {twi | twi in set trays & twi.IsTrayFull()},
			traysWith2Items = {tw2i | tw2i in set traysWithItems & tw2i.GetItem() <> nil and tw2i.GetItem().GetSizeOfTrays() = 2},
			itemsOnSorter = card traysWithItems, 
			twoTrayItemsOnSorter = card traysWith2Items,
			throughput = itemsOnSorter * SecInHour/runTime
		in 
			mk_ThroughputResult(itemsOnSorter, twoTrayItemsOnSorter, steps, items, throughput)
	pre trays <> {};
	

	sync

	mutex(RequestTray);  -- Only allows one induction at a time to induct items
	-- Mutex to ensure syncronization between InductionController and TrayAllocator
	mutex(RequestTray, CheckItemsToInduct);
	-- Permission predicate on Wait operation
	per Wait => threadid not in set dom itemsToInductMap;
	
	thread
		while (true) do
		(
		    -- Wait time equal to one tray step
			SorterEnviroment`trayStep.WaitSteps(1);
			CardReader(TrayStep`GetCounts() mod TrayAllocator`NumOfTrays + 1, <Empty>);
			
			-- Induct items for all waiting inductions
			CheckItemsToInduct();
		);

	traces

end TrayAllocator