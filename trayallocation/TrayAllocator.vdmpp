-- TrayAllocator in tray allocation for a sortation system
-- By José Antonio Esparza and Kim Bjerge - spring 2010

class TrayAllocator
	types

	values
		public InductionSeperation: nat = 4;
		public NumOfInductions : nat = 3;
		public NumOfTrays : nat = 20;
		public SecInHour : nat = 3600 	-- Number of seconds in an hour

	instance variables
		-- Ensure sufficient number of trays on sortering based on inductions and seperation
		inv NumOfTrays >= InductionSeperation * NumOfInductions; 

		countTraySteps : nat := 0;  	-- Used for calculation of throughput
		countItemsInducted : nat := 0;  -- Counts the number of items inducted 
		
		-- Induction group and invariants 
		public inductionGroup : seq of InductionController := [];
		inv len inductionGroup = NumOfInductions; 
		inv forall x,y in set elems inductionGroup &
			x <> y => x.GetId() <> y.GetId();
			
		-- Sorter ring and invariants	
		public sorterRing : inmap Tray`UID to Tray;
		inv card dom sorterRing = NumOfTrays;
		
		-- Tray at card reader and invariants
		public trayAtCardReader : Tray`UID := 0;
		inv trayAtCardReader > 0 => trayAtCardReader in set dom sorterRing;
						
	operations
	
    -- TrayAllocator constructor
	public TrayAllocator: SorterEnviroment==> TrayAllocator
	TrayAllocator(e) ==
	(
	    sorterRing := {num |-> new Tray(num) | num in set {1,...,NumOfTrays}};
	    inductionGroup := [new InductionController(self, num) | num in set {1,...,NumOfInductions}];
        e.AssignInductionGroup(inductionGroup);
	);

    -- Simulate sorter-ring moved one tray step
	public CardReader: Tray`UID * Tray`State  ==> ()
	CardReader(uid, state) ==
	(
	   	-- Update current tray at card reader
	    trayAtCardReader := uid;
	    
	    -- Simulate change of Tray state !!!
	    -- sorterRing(trayAtCardReader).SetState(state);
	 	
	 	-- Moved to SorterEnviroment
	 	--for all i in set {1,...,NumOfInductions} 
		--do 
		--   inductionGroup(i).TrayStep();
		   
		-- Count the number of tray steps 
		countTraySteps := countTraySteps + 1;
	)
	pre uid in set dom sorterRing;
	
	-- Inducting item on sorter if empty trays and no higher induction priority
	public InductItem: InductionController * Item ==> bool
	InductItem(ic, item) ==
	(
		if InductionsWithHigherPriority(ic)
		then
		 	return false
		else
			let numTrays = item.GetSizeOfTrays(),
				trays = AllocateTray(ic.GetId(), numTrays)
			in 
			    if trays = {}
			    then 
			    	return false
			    else
			    ( 
			    	countItemsInducted := countItemsInducted + 1;
			    	return PutItemOnTrays(item, trays)
			    ) 
	)
	pre ic in set elems inductionGroup;
	
	-- Returns true if sorter is full
	public IsSorterFull: () ==> bool
	IsSorterFull() ==
	 	return forall id in set dom sorterRing & sorterRing(id).GetState() = <Full>;

    -- Returns true if no higher priority of inductions in front of this induction
	private InductionsWithHigherPriority: InductionController ==> bool
	InductionsWithHigherPriority(ic) ==
		return exists i in set elems inductionGroup(ic.GetId()+1,...,len inductionGroup) & i.GetPriority() > ic.GetPriority()
	--	return exists i in set elems inductionGroup & i.GetId() > ic.GetId() and i.GetPriority() > ic.GetPriority()
	pre ic in set elems inductionGroup;

    -- Returns set of empty trays at trayAtCardReader
	private AllocateTray: nat * Item`ItemTraySize ==> set of Tray
	AllocateTray(icid, size) ==
	(
		-- Use of strategy pattern to compute the tray allocation
		dcl strategy : AllocatorStrategy;
		if size = 1 
			then strategy := new AllocatorOneTray(self)
			else strategy := new AllocatorTwoTray(self);

		return strategy.AllocateTray(icid);
	) 	
	pre icid in set inds inductionGroup and size <= 2; -- To be changed if ItemMaxTrays is increased
	
	-- Assign item on empty trays 
	private PutItemOnTrays: Item * set of Tray ==> bool
	PutItemOnTrays(item, trays) ==
		for all t in set trays
		do
			t.ItemOnTray(item)
	pre trays <> {} and forall t in set trays & t.IsTrayEmpty();
	
	-- Returns calculated throughput of soter capacity for current state of sorter ring
	public GetThroughput: () ==> nat * nat * nat * nat * real
	GetThroughput () ==
		CalculateThroughput(countTraySteps, rng sorterRing, countItemsInducted);
		
	functions

	-- Calculates the current throughput based on items on sorter ring 
	/*
	to be calculated as:  sum of simulation time steps = number of steps * Tray`TraySize/SorterEnviroment`Speed
    throughput calculated as items inducted in simulation time converted to items/hour 
    calculate the number of items inducted = number of tray with status equal <full> minus sum of two tray items divied by 2
	*/
	private CalculateThroughput: nat * set of Tray * nat-> nat * nat * nat * nat * real
	CalculateThroughput(steps, trays, items) ==
		let runTime :real = steps * (Tray`TraySize/SorterEnviroment`Speed),
			traysWithItems = {twi | twi in set trays & twi.IsTrayFull()},
			traysWith2Items = {tw2i | tw2i in set traysWithItems & tw2i.GetItem() <> nil and tw2i.GetItem().GetSizeOfTrays() = 2},
			itemsOnSorter = card traysWithItems, 
			twoTrayItemsOnSorter = card traysWith2Items,
			throughput = itemsOnSorter * SecInHour/runTime
		in 
			mk_(itemsOnSorter, twoTrayItemsOnSorter, steps, items, throughput)
	pre trays <> {};
	

	sync

	--thread

	traces

end TrayAllocator